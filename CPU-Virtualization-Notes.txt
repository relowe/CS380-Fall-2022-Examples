CPU Virtualization
  - Create the illusion of total control for each process.

  1.) We save the register state to memory every time we switch
      processes.
      
      - context switching
        1.) User process invokes ecall (or a timeout occurs)
        2.) The process jumps into the trap handler
            - push all the registers to the stack
        3.) Calls syscall
        4.) sycall returns to the trap handler
        5.) trap handler jumps back into user space
            - pop all the registers from the stack
            - sret

   2.) Memory Virtualiztion (Virtual Memory)
       - Map addresses onto arbitrary physical memory.


Full Accounting of a System Call (in Xv6)
=========================================
-user/ulib.c - Miniature version cstdlib and unix libraries
-user/usys.S - all of the systemcalls live
   - Generated by a perl script.
   - Code which enters the kernel:

     label: 
        li a7, SYS_###   # system call number
        ecall            # enter the kernel
        ret              # returns to the calling C function

     In risc-v C calling convention, arguments go in a# registers
     write(fd, buf, count)
       a0 - fd
       a1 - buf
       a2 - count
       ...
       a7 - SYS_write (constant)

       When a function returns, the return value is stored in a0

    Generalized  (Calling Convention of Xv6)
       a0 - parameter 1
       a1 - parameter 2
       a2 - parameter 3
       ...
       a6 - parameter 7
       a7 - System call number

  Kernel Side (after ecall)
    - trapframe which contains all of the process's registers
    - call the appropriate syscall hnadler based on a7
    - put the result in a0



